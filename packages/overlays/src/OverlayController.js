import '@lion/core/src/differentKeyEventNamesShimIE.js';
import { overlays } from './overlays.js';
import { containFocus } from './utils/contain-focus.js';
import './utils/typedef.js';

async function preloadPopper() {
  return import('popper.js/dist/esm/popper.min.js');
}

const GLOBAL_OVERLAYS_CONTAINER_CLASS = 'global-overlays__overlay-container';
const GLOBAL_OVERLAYS_CLASS = 'global-overlays__overlay';

/**
 * # About `contentNode`, `_contentNodeWrapper` and `_renderTarget`.
 *
 * There are subtle differences depending on the following factors:
 * - whether in global/local placement mode
 * - whether contentNode projected (`<div id="contentNodeWrapper"><slot name="contentNode"></slot></div>`)
 *
 * contentNode will always be untouched by OverlayController, so the Application Developer stays
 * in control of it as much as possible. It will only contain attributes needed for
 * accessibility.
 *
 * In local mode:
 * - contentNodeWrapper: will be provided to Popper.js and receives all positioning styles.
 * The wrapper allows for adding a content projected node an arrow as a sibling, like this:
 * ```
 * <div id="contentNodeWrapper">
 *   <slot name="contentNode"></slot>
 *   <my-arrow></my-arrow>
 * </div>
 * ```
 * It will be derived from surroundings when contentNode is projected. (in that
 * case, it can only be provided by the Application Developer)
 * When just a (non projected) contentNode is provided, contentNodeWrapper will be generated by
 * OverlyaController
 * - renderTarget: will be the host of the shadowRoot when contentNode is projected. It
 * will receive `contentNode` instead of `contentNodeWrapper`. For non projected contentNodes,
 * renderTarget will be the parent of contentNodeWrapper
 *
 * In global mode:
 * - contentNodeWrapper: will be part of globalRootNode that contains the html/css structure for
 * global overlays
 * - renderTarget: will be the parent of contentNodeWrapper
 */

export class OverlayController {
  /**
   * @constructor
   * @param {OverlayConfig} config initial config. Will be remembered as shared config
   * when `.updateConfig()` is called.
   */
  constructor(config = {}, manager = overlays) {
    this.__fakeExtendsEventTarget();
    this.manager = manager;
    this.__sharedConfig = config;
    this._defaultConfig = {
      placementMode: null,
      contentNode: config.contentNode,
      // For local config, a contentNodeWrapper can be provided. This is needed for
      // non projected content nodes with an arrow (in other cases contentNodeWrapper will be
      // found or created by OverlayController).
      contentNodeWrapper: config.contentNodeWrapper,
      invokerNode: config.invokerNode,
      backdropNode: config.backdropNode,
      referenceNode: null,
      elementToFocusAfterHide: config.invokerNode,
      inheritsReferenceWidth: '',
      hasBackdrop: false,
      isBlocking: false,
      preventsScroll: false,
      trapsKeyboardFocus: false,
      hidesOnEsc: false,
      hidesOnOutsideEsc: false,
      hidesOnOutsideClick: false,
      isTooltip: false,
      handlesUserInteraction: false,
      handlesAccessibility: false,
      popperConfig: {
        placement: 'top',
        positionFixed: false,
        modifiers: {
          keepTogether: {
            enabled: false,
          },
          preventOverflow: {
            enabled: true,
            boundariesElement: 'viewport',
            padding: 8, // viewport-margin for shifting/sliding
          },
          flip: {
            boundariesElement: 'viewport',
            padding: 16, // viewport-margin for flipping
          },
          offset: {
            enabled: true,
            offset: `0, 8px`, // horizontal and vertical margin (distance between popper and referenceElement)
          },
          arrow: {
            enabled: false,
          },
        },
      },
      viewportConfig: {
        placement: 'center',
      },
    };

    this.manager.add(this);

    this._contentId = `overlay-content--${Math.random()
      .toString(36)
      .substr(2, 10)}`;

    if (this._defaultConfig.contentNode) {
      this.__isContentNodeProjected = Boolean(this._defaultConfig.contentNode.assignedSlot);
      if (this.__isContentNodeProjected) {
        this.__contentNodeWrapperLocal = this._defaultConfig.contentNode.assignedSlot.parentNode;
      }
    }

    this.updateConfig(config);

    this.__hasActiveTrapsKeyboardFocus = false;
    this.__hasActiveBackdrop = true;
  }

  get invoker() {
    return this.invokerNode;
  }

  get content() {
    return this._contentNodeWrapper;
  }

  /**
   * @desc The element ._contentNodeWrapper will be appended to.
   * If viewportConfig is configured, this will be OverlayManager.globalRootNode
   * If popperConfig is configured, this will be a sibling node of invokerNode
   */
  get _renderTarget() {
    if (this.placementMode === 'global') {
      return this.manager.globalRootNode;
    }
    if (this.__isContentNodeProjected) {
      return this.__originalContentParent.getRootNode().host;
    }
    return this.__originalContentParent;
  }

  /**
   * @desc The element our local overlay will be positioned relative to.
   */
  get _referenceNode() {
    return this.referenceNode || this.invokerNode;
  }

  set elevation(value) {
    if (this._contentNodeWrapper) {
      this._contentNodeWrapper.style.zIndex = value;
    }
    if (this.backdropNode) {
      this.backdropNode.style.zIndex = value;
    }
  }

  get elevation() {
    return this._contentNodeWrapper.zIndex;
  }

  /**
   * @desc Allows to dynamically change the overlay configuration. Needed in case the
   * presentation of the overlay changes depending on screen size.
   * Note that this method is the only allowed way to update a configuration of an
   * OverlayController instance.
   * @param { OverlayConfig } cfgToAdd
   */
  updateConfig(cfgToAdd) {
    // Teardown all previous configs
    this._handleFeatures({ phase: 'teardown' });

    this.__prevConfig = this.config || {};

    this.config = {
      ...this._defaultConfig, // our basic ingredients
      ...this.__sharedConfig, // the initial configured overlayController
      ...cfgToAdd, // the added config
      popperConfig: {
        ...(this._defaultConfig.popperConfig || {}),
        ...(this.__sharedConfig.popperConfig || {}),
        ...(cfgToAdd.popperConfig || {}),
        modifiers: {
          ...((this._defaultConfig.popperConfig && this._defaultConfig.popperConfig.modifiers) ||
            {}),
          ...((this.__sharedConfig.popperConfig && this.__sharedConfig.popperConfig.modifiers) ||
            {}),
          ...((cfgToAdd.popperConfig && cfgToAdd.popperConfig.modifiers) || {}),
        },
      },
    };

    this.__validateConfiguration(this.config);
    Object.assign(this, this.config);
    this._init({ cfgToAdd });
  }

  // eslint-disable-next-line class-methods-use-this
  __validateConfiguration(newConfig) {
    if (!newConfig.placementMode) {
      throw new Error('You need to provide a .placementMode ("global"|"local")');
    }
    if (!['global', 'local'].includes(newConfig.placementMode)) {
      throw new Error(
        `"${newConfig.placementMode}" is not a valid .placementMode, use ("global"|"local")`,
      );
    }
    if (!newConfig.contentNode) {
      throw new Error('You need to provide a .contentNode');
    }
  }

  async _init({ cfgToAdd }) {
    this.__initContentNodeWrapper({ cfgToAdd });
    this.__initConnectionTarget();
    if (this.handlesAccessibility) {
      this.__initAccessibility({ cfgToAdd });
    }

    if (this.placementMode === 'local') {
      // Now, it is time to lazily load Popper if not done yet
      // Do we really want to add display: inline or is this up to user?
      if (!this.constructor.popperModule) {
        this.constructor.popperModule = preloadPopper();
      }
    }
    this._handleFeatures({ phase: 'init' });
  }

  __initConnectionTarget() {
    // Now, add our node to the right place in dom (renderTarget)
    if (this._contentNodeWrapper !== this.__prevConfig._contentNodeWrapper) {
      if (this.config.placementMode === 'global' || !this.__isContentNodeProjected) {
        this._contentNodeWrapper.appendChild(this.contentNode);
      }
    }

    if (this.__isContentNodeProjected && this.placementMode === 'local') {
      // We add the contentNode in its slot, so that it will be projected by contentNodeWrapper
      this._renderTarget.appendChild(this.contentNode);
    } else {
      const isInsideRenderTarget = this._renderTarget === this._contentNodeWrapper.parentNode;
      if (!isInsideRenderTarget) {
        // ContentNodeWrapper becomes the direct (non projected) parent of contentNode
        this._renderTarget.appendChild(this._contentNodeWrapper);
      }
    }
  }

  /**
   * @desc Cleanup ._contentNodeWrapper. We do this, because creating a fresh wrapper
   * can lead to problems with event listeners...
   */
  __initContentNodeWrapper({ cfgToAdd }) {
    if (this.config.contentNodeWrapper && this.placementMode === 'local') {
      this._contentNodeWrapper = this.config.contentNodeWrapper;
    } else if (this.__isContentNodeProjected && this.placementMode === 'local') {
      this._contentNodeWrapper = this.__contentNodeWrapperLocal;
    } else {
      this._contentNodeWrapper = document.createElement('div');
    }

    this._contentNodeWrapper.style.cssText = null;
    this._contentNodeWrapper.style.display = 'none';

    if (getComputedStyle(this.contentNode).position === 'absolute') {
      // Having a _contWrapperNode and a contentNode with 'position:absolute' results in
      // computed height of 0...
      this.contentNode.style.position = 'static';
    }

    if (this.__isContentNodeProjected && this._contentNodeWrapper.isConnected) {
      // We need to keep track of the original local context.
      this.__originalContentParent = this._contentNodeWrapper.parentNode;
    } else if (cfgToAdd.contentNode && cfgToAdd.contentNode.isConnected) {
      // We need to keep track of the original local context.
      this.__originalContentParent = this.contentNode.parentNode;
    }
  }

  /**
   * @desc Display local overlays on top of elements with no z-index that appear later in the DOM
   */
  _handleZIndex({ phase }) {
    if (this.placementMode !== 'local') {
      return;
    }

    if (phase === 'setup') {
      const zIndexNumber = Number(getComputedStyle(this.contentNode).zIndex);
      if (zIndexNumber < 1 || Number.isNaN(zIndexNumber)) {
        this._contentNodeWrapper.style.zIndex = 1;
      }
    }
  }

  __initAccessibility() {
    // TODO: remove a11y attributes on teardown
    if (!this.contentNode.id) {
      this.contentNode.setAttribute('id', this._contentId);
    }
    if (this.isTooltip) {
      if (this.invokerNode) {
        this.invokerNode.setAttribute(
          this.invokerRelation === 'label' ? 'aria-labelledby' : 'aria-describedby',
          this._contentId,
        );
      }
      this.contentNode.setAttribute('role', 'tooltip');
    } else {
      if (this.invokerNode) {
        this.invokerNode.setAttribute('aria-expanded', this.isShown);
      }
      if (!this.contentNode.role) {
        this.contentNode.setAttribute('role', 'dialog');
      }
    }
  }

  get isShown() {
    return Boolean(this._contentNodeWrapper.style.display !== 'none');
  }

  /**
   * @event before-show right before the overlay shows. Used for animations and switching overlays
   * @event show right after the overlay is shown
   * @param {HTMLElement} elementToFocusAfterHide
   */
  async show(elementToFocusAfterHide = this.elementToFocusAfterHide) {
    if (this.manager) {
      this.manager.show(this);
    }

    if (this.isShown) {
      return;
    }

    const event = new CustomEvent('before-show', { cancelable: true });
    this.dispatchEvent(event);
    if (!event.defaultPrevented) {
      this._contentNodeWrapper.style.display = '';
      await this._handleFeatures({ phase: 'show' });
      await this._handlePosition({ phase: 'show' });
      this.elementToFocusAfterHide = elementToFocusAfterHide;
      this.dispatchEvent(new Event('show'));
    }
  }

  async _handlePosition({ phase }) {
    if (this.placementMode === 'global') {
      const addOrRemove = phase === 'show' ? 'add' : 'remove';
      const placementClass = `${GLOBAL_OVERLAYS_CONTAINER_CLASS}--${this.viewportConfig.placement}`;
      this._contentNodeWrapper.classList[addOrRemove](GLOBAL_OVERLAYS_CONTAINER_CLASS);
      this._contentNodeWrapper.classList[addOrRemove](placementClass);
      this.contentNode.classList[addOrRemove](GLOBAL_OVERLAYS_CLASS);
    } else if (this.placementMode === 'local' && phase === 'show') {
      /**
       * Popper is weird about properly positioning the popper element when it is recreated so
       * we just recreate the popper instance to make it behave like it should.
       * Probably related to this issue: https://github.com/FezVrasta/popper.js/issues/796
       * calling just the .update() function on the popper instance sadly does not resolve this.
       * This is however necessary for initial placement.
       */
      await this.__createPopperInstance();
      this._popper.update();
    }
  }

  /**
   * @event before-hide right before the overlay hides. Used for animations and switching overlays
   * @event hide right after the overlay is hidden
   */
  async hide() {
    if (this.manager) {
      this.manager.hide(this);
    }

    if (!this.isShown) {
      return;
    }

    const event = new CustomEvent('before-hide', { cancelable: true });
    this.dispatchEvent(event);
    if (!event.defaultPrevented) {
      // await this.transitionHide({ backdropNode: this.backdropNode, conentNode: this.contentNode });
      this._contentNodeWrapper.style.display = 'none';
      this._handleFeatures({ phase: 'hide' });
      this.dispatchEvent(new Event('hide'));
      this._restoreFocus();
    }
  }

  // eslint-disable-next-line class-methods-use-this, no-empty-function, no-unused-vars
  async transitionHide({ backdropNode, contentNode }) {}

  _restoreFocus() {
    // We only are allowed to move focus if we (still) 'own' it.
    // Otherwise we assume the 'outside world' has, purposefully, taken over
    // if (this._contentNodeWrapper.activeElement) {
    if (this.elementToFocusAfterHide) {
      this.elementToFocusAfterHide.focus();
    }
    // }
  }

  async toggle() {
    return this.isShown ? this.hide() : this.show();
  }

  /**
   * @desc All features are handled here. Every feature is set up on show
   * and torn
   * @param {object} config
   * @param {'init'|'show'|'hide'|'teardown'} config.phase
   */
  async _handleFeatures({ phase }) {
    this._handleZIndex({ phase });

    if (this.preventsScroll) {
      this._handlePreventsScroll({ phase });
    }
    if (this.isBlocking) {
      this._handleBlocking({ phase });
    }
    if (this.hasBackdrop) {
      this._handleBackdrop({ phase });
    }
    if (this.trapsKeyboardFocus) {
      this._handleTrapsKeyboardFocus({ phase });
    }
    if (this.hidesOnEsc) {
      this._handleHidesOnEsc({ phase });
    }
    if (this.hidesOnOutsideEsc) {
      this._handleHidesOnOutsideEsc({ phase });
    }
    if (this.hidesOnOutsideClick) {
      this._handleHidesOnOutsideClick({ phase });
    }
    if (this.handlesAccessibility) {
      this._handleAccessibility({ phase });
    }
    if (this.inheritsReferenceWidth) {
      this._handleInheritsReferenceWidth();
    }
  }

  _handlePreventsScroll({ phase }) {
    switch (phase) {
      case 'show':
        this.manager.requestToPreventScroll();
        break;
      case 'hide':
        this.manager.requestToEnableScroll();
        break;
      /* no default */
    }
  }

  _handleBlocking({ phase }) {
    switch (phase) {
      case 'show':
        this.manager.requestToShowOnly(this);
        break;
      case 'hide':
        this.manager.retractRequestToShowOnly(this);
        break;
      /* no default */
    }
  }

  get hasActiveBackdrop() {
    return this.__hasActiveBackdrop;
  }

  /**
   * @desc Sets up backdrop on the given overlay. If there was a backdrop on another element
   * it is removed. Otherwise this is the first time displaying a backdrop, so a fade-in
   * animation is played.
   */
  _handleBackdrop({ animation = true, phase }) {
    if (this.placementMode === 'local') {
      switch (phase) {
        case 'init':
          if (!this.backdropNode) {
            this.backdropNode = document.createElement('div');
            this.backdropNode.classList.add('local-overlays__backdrop');
          }
          // this.backdropNode.slot = '_overlay-shadow-outlet';
          this._contentNodeWrapper.parentNode.insertBefore(
            this.backdropNode,
            this._contentNodeWrapper,
          );
          break;
        case 'show':
          this.__hasActiveBackdrop = true;
          break;
        case 'hide':
          if (!this.backdropNode) {
            return;
          }
          this.__hasActiveBackdrop = false;
          break;
        case 'teardown':
          if (!this.backdropNode) {
            return;
          }
          this.backdropNode.parentNode.removeChild(this.backdropNode);
          break;
        /* no default */
      }
      return;
    }
    const { backdropNode } = this;
    switch (phase) {
      case 'init':
        this.backdropNode = document.createElement('div');
        this.backdropNode.classList.add('global-overlays__backdrop');
        this._contentNodeWrapper.parentElement.insertBefore(
          this.backdropNode,
          this._contentNodeWrapper,
        );
        break;
      case 'show':
        backdropNode.classList.add('global-overlays__backdrop--visible');
        if (animation === true) {
          backdropNode.classList.add('global-overlays__backdrop--fade-in');
        }
        this.__hasActiveBackdrop = true;
        break;
      case 'hide':
        if (!backdropNode) {
          return;
        }
        backdropNode.classList.remove('global-overlays__backdrop--fade-in');

        if (animation) {
          let afterFadeOut;
          backdropNode.classList.add('global-overlays__backdrop--fade-out');
          this.__backDropAnimation = new Promise(resolve => {
            afterFadeOut = () => {
              backdropNode.classList.remove('global-overlays__backdrop--fade-out');
              backdropNode.classList.remove('global-overlays__backdrop--visible');
              backdropNode.removeEventListener('animationend', afterFadeOut);
              resolve();
            };
          });
          backdropNode.addEventListener('animationend', afterFadeOut);
        } else {
          backdropNode.classList.remove('global-overlays__backdrop--visible');
        }
        this.__hasActiveBackdrop = false;
        break;
      case 'teardown':
        if (!backdropNode) {
          return;
        }
        if (animation && this.__backDropAnimation) {
          this.__backDropAnimation.then(() => {
            backdropNode.parentNode.removeChild(backdropNode);
          });
        } else {
          backdropNode.parentNode.removeChild(backdropNode);
        }
        break;
      /* no default */
    }
  }

  get hasActiveTrapsKeyboardFocus() {
    return this.__hasActiveTrapsKeyboardFocus;
  }

  _handleTrapsKeyboardFocus({ phase }) {
    if (phase === 'show') {
      this.enableTrapsKeyboardFocus();
    } else if (phase === 'hide') {
      this.disableTrapsKeyboardFocus();
    }
  }

  enableTrapsKeyboardFocus() {
    if (this.__hasActiveTrapsKeyboardFocus) {
      return;
    }
    if (this.manager) {
      this.manager.disableTrapsKeyboardFocusForAll();
    }
    this._containFocusHandler = containFocus(this.contentNode);
    this.__hasActiveTrapsKeyboardFocus = true;
    if (this.manager) {
      this.manager.informTrapsKeyboardFocusGotEnabled();
    }
  }

  disableTrapsKeyboardFocus({ findNewTrap = true } = {}) {
    if (!this.__hasActiveTrapsKeyboardFocus) {
      return;
    }
    if (this._containFocusHandler) {
      this._containFocusHandler.disconnect();
      this._containFocusHandler = undefined;
    }
    this.__hasActiveTrapsKeyboardFocus = false;
    if (this.manager) {
      this.manager.informTrapsKeyboardFocusGotDisabled({ disabledCtrl: this, findNewTrap });
    }
  }

  _handleHidesOnEsc({ phase }) {
    if (phase === 'show') {
      this.__escKeyHandler = ev => ev.key === 'Escape' && this.hide();
      this.contentNode.addEventListener('keyup', this.__escKeyHandler);
      if (this.invokerNode) {
        this.invokerNode.addEventListener('keyup', this.__escKeyHandler);
      }
    } else if (phase === 'hide') {
      this.contentNode.removeEventListener('keyup', this.__escKeyHandler);
      if (this.invokerNode) {
        this.invokerNode.removeEventListener('keyup', this.__escKeyHandler);
      }
    }
  }

  _handleHidesOnOutsideEsc({ phase }) {
    if (phase === 'show') {
      this.__escKeyHandler = ev => ev.key === 'Escape' && this.hide();
      document.addEventListener('keyup', this.__escKeyHandler);
    } else if (phase === 'hide') {
      document.removeEventListener('keyup', this.__escKeyHandler);
    }
  }

  _handleInheritsReferenceWidth() {
    if (!this._referenceNode || this.placementMode === 'global') {
      return;
    }

    const referenceWidth = `${this._referenceNode.clientWidth}px`;
    switch (this.inheritsReferenceWidth) {
      case 'max':
        this._contentNodeWrapper.style.maxWidth = referenceWidth;
        break;
      case 'full':
        this._contentNodeWrapper.style.width = referenceWidth;
        break;
      case 'min':
        this._contentNodeWrapper.style.minWidth = referenceWidth;
        this._contentNodeWrapper.style.width = 'auto';
        break;
      /* no default */
    }
  }

  _handleHidesOnOutsideClick({ phase }) {
    const addOrRemoveListener = phase === 'show' ? 'addEventListener' : 'removeEventListener';

    if (phase === 'show') {
      let wasClickInside = false;
      // handle on capture phase and remember till the next task that there was an inside click
      this.__preventCloseOutsideClick = () => {
        wasClickInside = true;
        setTimeout(() => {
          wasClickInside = false;
        });
      };
      // handle on capture phase and schedule the hide if needed
      this.__onCaptureHtmlClick = () => {
        setTimeout(() => {
          if (wasClickInside === false) {
            this.hide();
          }
        });
      };
    }

    this._contentNodeWrapper[addOrRemoveListener]('click', this.__preventCloseOutsideClick, true);
    if (this.invokerNode) {
      this.invokerNode[addOrRemoveListener]('click', this.__preventCloseOutsideClick, true);
    }
    document.documentElement[addOrRemoveListener]('click', this.__onCaptureHtmlClick, true);
  }

  _handleAccessibility({ phase }) {
    if (this.invokerNode && !this.isTooltip) {
      this.invokerNode.setAttribute('aria-expanded', phase === 'show');
    }
  }

  teardown() {
    this._handleFeatures({ phase: 'teardown' });

    // Remove the content node wrapper from the global rootnode
    this._teardownContentNodeWrapper();
  }

  _teardownContentNodeWrapper() {
    if (
      this.placementMode === 'global' &&
      this._contentNodeWrapper &&
      this._contentNodeWrapper.parentNode
    ) {
      this._contentNodeWrapper.parentNode.removeChild(this._contentNodeWrapper);
    }
  }

  async __createPopperInstance() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
    const { default: Popper } = await this.constructor.popperModule;
    this._popper = new Popper(this._referenceNode, this._contentNodeWrapper, {
      ...this.config.popperConfig,
    });
  }

  __fakeExtendsEventTarget() {
    const delegate = document.createDocumentFragment();
    ['addEventListener', 'dispatchEvent', 'removeEventListener'].forEach(funcName => {
      this[funcName] = (...args) => delegate[funcName](...args);
    });
  }
}
